<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/assets/styles.css">
    <link rel="stylesheet" href="/assets/notes.css">
    <link rel="stylesheet" href="/assets/hljs-github.css">
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        messageStyle: "none",
        tex2jax: {
          inlineMath: [["$", "$"], ["\\(", "\\)"]],
          processEscapes: true
        },
        "HTML-CSS": {
          availableFonts: ["TeX"]
        }
      });
    </script>
    <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
  </head>
  <body>
    <div class="content"><h1 id="mathematica">Mathematica</h1>
<pre><code>Clear[&quot;Global`*&quot;]
</code></pre><p>Separate contexts/scopes for notebooks: <a href="http://stackoverflow.com/a/4897013">http://stackoverflow.com/a/4897013</a></p>
<h2 id="quantum-information">Quantum information</h2>
<h3 id="bras-and-kets">Bras and kets</h3>
<pre><code class="mathematica">bra[str_] := {Flatten[Apply[TensorProduct, Map[If[#1 == "0", {1, 0}, {0, 1}] &amp;, <span class="hljs-keyword">Characters</span>[str]]]]};
ket[str_] := <span class="hljs-keyword">Transpose</span>[bra[str]];
</code></pre>
<p><strong>Usage example:</strong></p>
<pre><code class="mathematica">bra[<span class="hljs-string">"010"</span>] <span class="hljs-comment">(* row vector: {{1, 0, 0, 0, 0, 0, 0, 0}} *)</span>
ket[<span class="hljs-string">"010"</span>] <span class="hljs-comment">(* col vector: {{1}, {0}, {0}, {0}, {0}, {0}, {0}, {0}} *)</span>
bra[<span class="hljs-string">"000"</span>].ket[<span class="hljs-string">"001"</span>] <span class="hljs-comment">(* 0 *)</span>
bra[<span class="hljs-string">"000"</span>].ket[<span class="hljs-string">"000"</span>] <span class="hljs-comment">(* 1 *)</span>
ket[<span class="hljs-string">"000"</span>].bra[<span class="hljs-string">"000"</span>] <span class="hljs-comment">(* the correct matrix *)</span>
<span class="hljs-keyword">ConjugateTranspose</span>[ket[<span class="hljs-string">"010"</span>]] == bra[<span class="hljs-string">"010"</span>] <span class="hljs-comment">(* True *)</span>
</code></pre>
<h3 id="partial-transpose">Partial transpose</h3>
<p>The partial trace $\mathrm{tr}_\alpha(\rho)$ can be computed with</p>
<pre><code class="mathematica">pTr[mat_, k_] := <span class="hljs-keyword">Module</span>[{n, indices, bbra, kket},
  n = <span class="hljs-keyword">Log</span>[<span class="hljs-number">2</span>, <span class="hljs-keyword">Dimensions</span>[mat][[<span class="hljs-number">1</span>]]];
  indices = <span class="hljs-keyword">Characters</span>[<span class="hljs-keyword">Table</span>[<span class="hljs-keyword">IntegerString</span>[j, <span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>], {j, 0, 2^(n - 1) - 1}]];
  bbra[i_] := <span class="hljs-keyword">Module</span>[{inner, j, jj},
    inner = {};
    jj = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">For</span>[j = <span class="hljs-number">1</span>, j &lt;= n, j++,
     inner = <span class="hljs-keyword">Append</span>[inner,
       <span class="hljs-keyword">If</span>[<span class="hljs-keyword">MemberQ</span>[k, j] \[<span class="hljs-keyword">Or</span>] j == k, jj++; bra[i[[jj]]], <span class="hljs-keyword">IdentityMatrix</span>[<span class="hljs-number">2</span>]]]];
    <span class="hljs-keyword">Apply</span>[<span class="hljs-keyword">KroneckerProduct</span>, inner]];
  <span class="hljs-keyword">Total</span>[<span class="hljs-keyword">Table</span>[bbra[i].mat.<span class="hljs-keyword">ConjugateTranspose</span>[bbra[i]], {i, indices}]]];
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="mathematica">pTr(\[Rho], <span class="hljs-number">2</span>)     <span class="hljs-comment">(* trace out subsystem 2 *)</span>
pTr(\[Rho], {2})   <span class="hljs-comment">(* trace out subsystem 2 *)</span>
pTr(\[Rho], {1,2}) <span class="hljs-comment">(* trace out subsystem 1 and 2)</span>
</code></pre>
<p><strong>Example:</strong></p>
<p>Consider three qubits. The state space is the hilbert space $\mathcal{H}<em>1\otimes\mathcal{H}_2\otimes\mathcal{H}_3$. A state can be written $\ket{\psi} = \alpha_0\ket{000} + \alpha_1\ket{001} + \cdots + \alpha_7\ket{111}$. The corresponding (pure) density matrix is then $\rho = \ket{\psi}\bra{\psi}$. The corresponding reduced density operator $\rho_1 = \mathrm{tr}</em>{23}(\rho)$ is</p>
<pre><code class="mathematica"><span class="hljs-keyword">$Assumptions</span> = {\[Alpha] \[Element] Reals, \[Beta] \[Element] Reals};
\[Psi] = <span class="hljs-keyword">Sqrt</span>[<span class="hljs-number">2</span>/<span class="hljs-number">3</span>] (\[Alpha] ket[<span class="hljs-string">"000"</span>] - \[<span class="hljs-keyword">Beta</span>] ket[<span class="hljs-string">"111"</span>]) -
         \[Alpha]/<span class="hljs-keyword">Sqrt</span>[<span class="hljs-number">6</span>] (ket[<span class="hljs-string">"011"</span>] + ket[<span class="hljs-string">"101"</span>]) +
         \[<span class="hljs-keyword">Beta</span>]/<span class="hljs-keyword">Sqrt</span>[<span class="hljs-number">6</span>] (ket[<span class="hljs-string">"010"</span>] + ket[<span class="hljs-string">"100"</span>]);
\[Rho] = \[Psi].<span class="hljs-keyword">ConjugateTranspose</span>[\[Psi]] // <span class="hljs-keyword">FullSimplify</span>;
\[Rho] // <span class="hljs-keyword">MatrixForm</span>
\[Rho]<span class="hljs-number">1</span> = pTr[\[Rho], {2,3}] // <span class="hljs-keyword">FullSimplify</span> // <span class="hljs-keyword">Expand</span> // <span class="hljs-keyword">MatrixForm</span>
</code></pre>
</div>
    <!-- <div class="footer-separator"></div> -->
    <!-- <div class="footer"><div class="footer-inner">Viktor Qvarfordt</div></div> -->
  </body>
</html>
